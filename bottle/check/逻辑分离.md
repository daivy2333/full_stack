# 漂流瓶项目逻辑分离方案

## 概述
本文档总结了可以将业务逻辑从前端和后端代码中移入数据库存储过程的实现方案，以实现前端专注界面展示、运行逻辑都在数据库里的分离。

## 当前架构分析

### 前端职责
- UI渲染和交互
- 调用API获取数据
- 用户认证令牌管理
- 本地状态管理（临时状态）

### 后端职责
- API路由定义
- 数据库查询和操作
- 用户认证和授权
- 业务逻辑处理

## 可移入数据库存储过程的逻辑

### 1. 漂流瓶相关逻辑

#### 1.1 获取随机漂流瓶逻辑
**当前实现位置**：`backend/routes/bottles.js` 第8-107行
**可优化内容**：
- 已部分实现存储过程 `get_random_unseen_bottle`，但可以进一步优化
- 增加对匿名用户的处理逻辑
- 在存储过程中直接计算点赞、点踩数和用户反应

**建议存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS get_random_bottle_with_stats(
  IN p_user_id INT
)
BEGIN
  DECLARE v_bottle_id INT;
  DECLARE v_user_id INT;

  -- 获取随机漂流瓶ID
  SELECT id INTO v_bottle_id
  FROM bottles
  WHERE is_active = TRUE
  AND (p_user_id IS NULL OR id NOT IN (
    SELECT bottle_id FROM user_bottle_views WHERE user_id = p_user_id
  ))
  ORDER BY RAND()
  LIMIT 1;

  -- 如果找不到漂流瓶，返回空结果
  IF v_bottle_id IS NULL THEN
    SELECT NULL AS id;
  ELSE
    -- 获取漂流瓶详情及统计信息
    SELECT 
      b.id,
      b.message,
      COALESCE(b.author_name, u.username) AS author,
      DATE(b.created_at) AS date,
      COALESCE(like_stats.like_count, 0) AS likes,
      COALESCE(dislike_stats.dislike_count, 0) AS dislikes,
      b.views,
      COALESCE(user_reaction.reaction_type, NULL) AS userReaction
    FROM bottles b
    JOIN users u ON b.user_id = u.id
    LEFT JOIN (
      SELECT bottle_id, COUNT(*) AS like_count
      FROM user_bottle_reactions
      WHERE reaction_type = 'like'
      GROUP BY bottle_id
    ) like_stats ON b.id = like_stats.bottle_id
    LEFT JOIN (
      SELECT bottle_id, COUNT(*) AS dislike_count
      FROM user_bottle_reactions
      WHERE reaction_type = 'dislike'
      GROUP BY bottle_id
    ) dislike_stats ON b.id = dislike_stats.bottle_id
    LEFT JOIN user_bottle_reactions user_reaction ON b.id = user_reaction.bottle_id 
      AND user_reaction.user_id = p_user_id
    WHERE b.id = v_bottle_id;

    -- 如果用户已登录，记录浏览并增加浏览次数
    IF p_user_id IS NOT NULL THEN
      INSERT INTO user_bottle_views (user_id, bottle_id) 
      VALUES (p_user_id, v_bottle_id) 
      ON DUPLICATE KEY UPDATE viewed_at = NOW();

      UPDATE bottles SET views = views + 1 WHERE id = v_bottle_id;
    END IF;
  END IF;
END //
DELIMITER ;
```

#### 1.2 漂流瓶反应逻辑
**当前实现位置**：`backend/routes/bottles.js` 第167-271行
**可优化内容**：
- 将点赞/点踩逻辑移入存储过程
- 自动更新bottles表中的likes和dislikes字段
- 返回更新后的统计信息

**建议存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS react_to_bottle(
  IN p_user_id INT,
  IN p_bottle_id INT,
  IN p_reaction_type VARCHAR(10)
)
BEGIN
  DECLARE v_old_reaction_type VARCHAR(10);
  DECLARE v_exists INT;

  -- 检查漂流瓶是否存在
  SELECT COUNT(*) INTO v_exists
  FROM bottles
  WHERE id = p_bottle_id AND is_active = TRUE;

  IF v_exists = 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '漂流瓶不存在';
  END IF;

  -- 获取用户之前的反应
  SELECT reaction_type INTO v_old_reaction_type
  FROM user_bottle_reactions
  WHERE user_id = p_user_id AND bottle_id = p_bottle_id;

  -- 处理反应
  IF v_old_reaction_type IS NULL THEN
    -- 新增反应
    INSERT INTO user_bottle_reactions (user_id, bottle_id, reaction_type)
    VALUES (p_user_id, p_bottle_id, p_reaction_type);

    -- 更新bottles表
    IF p_reaction_type = 'like' THEN
      UPDATE bottles SET likes = likes + 1 WHERE id = p_bottle_id;
    ELSEIF p_reaction_type = 'dislike' THEN
      UPDATE bottles SET dislikes = dislikes + 1 WHERE id = p_bottle_id;
    END IF;
  ELSEIF v_old_reaction_type != p_reaction_type THEN
    -- 更改反应类型
    UPDATE user_bottle_reactions 
    SET reaction_type = p_reaction_type, created_at = NOW()
    WHERE user_id = p_user_id AND bottle_id = p_bottle_id;

    -- 更新bottles表
    IF v_old_reaction_type = 'like' AND p_reaction_type = 'dislike' THEN
      UPDATE bottles SET likes = likes - 1, dislikes = dislikes + 1 WHERE id = p_bottle_id;
    ELSEIF v_old_reaction_type = 'dislike' AND p_reaction_type = 'like' THEN
      UPDATE bottles SET likes = likes + 1, dislikes = dislikes - 1 WHERE id = p_bottle_id;
    END IF;
  END IF;

  -- 返回更新后的统计信息
  SELECT 
    COUNT(CASE WHEN reaction_type = 'like' THEN 1 END) AS likes,
    COUNT(CASE WHEN reaction_type = 'dislike' THEN 1 END) AS dislikes,
    p_reaction_type AS userReaction
  FROM user_bottle_reactions
  WHERE bottle_id = p_bottle_id;
END //
DELIMITER ;
```

#### 1.3 漂流瓶详情逻辑
**当前实现位置**：`backend/routes/bottles.js` 第274-343行
**可优化内容**：
- 将获取漂流瓶详情的逻辑移入存储过程
- 在存储过程中直接计算点赞、点踩数和用户反应

**建议存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS get_bottle_details(
  IN p_user_id INT,
  IN p_bottle_id INT
)
BEGIN
  -- 检查漂流瓶是否存在
  IF NOT EXISTS (SELECT 1 FROM bottles WHERE id = p_bottle_id AND is_active = TRUE) THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '漂流瓶不存在';
  END IF;

  -- 返回漂流瓶详情及统计信息
  SELECT 
    b.id,
    b.message,
    COALESCE(b.author_name, u.username) AS author,
    DATE(b.created_at) AS date,
    COALESCE(like_stats.like_count, 0) AS likes,
    COALESCE(dislike_stats.dislike_count, 0) AS dislikes,
    b.views,
    COALESCE(user_reaction.reaction_type, NULL) AS userReaction
  FROM bottles b
  JOIN users u ON b.user_id = u.id
  LEFT JOIN (
    SELECT bottle_id, COUNT(*) AS like_count
    FROM user_bottle_reactions
    WHERE reaction_type = 'like'
    GROUP BY bottle_id
  ) like_stats ON b.id = like_stats.bottle_id
  LEFT JOIN (
    SELECT bottle_id, COUNT(*) AS dislike_count
    FROM user_bottle_reactions
    WHERE reaction_type = 'dislike'
    GROUP BY bottle_id
  ) dislike_stats ON b.id = dislike_stats.bottle_id
  LEFT JOIN user_bottle_reactions user_reaction ON b.id = user_reaction.bottle_id 
    AND user_reaction.user_id = p_user_id
  WHERE b.id = p_bottle_id;
END //
DELIMITER ;
```

### 2. 用户相关逻辑

#### 2.1 用户状态管理逻辑
**当前实现位置**：`backend/routes/user.js` 第7-83行和第86-172行
**可优化内容**：
- 将获取和更新用户状态的逻辑移入存储过程
- 在存储过程中处理日期变化和状态重置

**建议存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS get_user_state(
  IN p_user_id INT
)
BEGIN
  DECLARE v_today DATE DEFAULT CURDATE();
  DECLARE v_state_exists INT;

  -- 检查用户状态是否存在
  SELECT COUNT(*) INTO v_state_exists
  FROM user_states
  WHERE user_id = p_user_id;

  -- 如果状态不存在，创建默认状态
  IF v_state_exists = 0 THEN
    INSERT INTO user_states (user_id) VALUES (p_user_id);
  END IF;

  -- 检查日期是否变化，如果变化则重置状态
  UPDATE user_states
  SET 
    has_picked_today = IF(last_pick_date = v_today, has_picked_today, FALSE),
    has_thrown_today = IF(last_throw_date = v_today, has_thrown_today, FALSE)
  WHERE user_id = p_user_id;

  -- 返回用户状态
  SELECT 
    has_picked_today AND last_pick_date = v_today AS hasPickedToday,
    has_thrown_today AND last_throw_date = v_today AS hasThrownToday,
    last_pick_date AS lastPickDate,
    last_throw_date AS lastThrowDate,
    current_view AS currentView,
    dev_mode AS devMode,
    has_seen_tutorial AS hasSeenTutorial
  FROM user_states
  WHERE user_id = p_user_id;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE IF NOT EXISTS update_user_state(
  IN p_user_id INT,
  IN p_has_picked_today BOOLEAN,
  IN p_has_thrown_today BOOLEAN,
  IN p_current_view VARCHAR(10),
  IN p_dev_mode BOOLEAN,
  IN p_has_seen_tutorial BOOLEAN
)
BEGIN
  DECLARE v_today DATE DEFAULT CURDATE();
  DECLARE v_state_exists INT;

  -- 检查用户状态是否存在
  SELECT COUNT(*) INTO v_state_exists
  FROM user_states
  WHERE user_id = p_user_id;

  -- 如果状态不存在，创建默认状态
  IF v_state_exists = 0 THEN
    INSERT INTO user_states (user_id) VALUES (p_user_id);
  END IF;

  -- 更新用户状态
  UPDATE user_states
  SET 
    has_picked_today = IF(p_has_picked_today IS NOT NULL, p_has_picked_today, has_picked_today),
    has_thrown_today = IF(p_has_thrown_today IS NOT NULL, p_has_thrown_today, has_thrown_today),
    last_pick_date = IF(p_has_picked_today IS NOT NULL AND p_has_picked_today = TRUE, v_today, last_pick_date),
    last_throw_date = IF(p_has_thrown_today IS NOT NULL AND p_has_thrown_today = TRUE, v_today, last_throw_date),
    current_view = IF(p_current_view IS NOT NULL, p_current_view, current_view),
    dev_mode = IF(p_dev_mode IS NOT NULL, p_dev_mode, dev_mode),
    has_seen_tutorial = IF(p_has_seen_tutorial IS NOT NULL, p_has_seen_tutorial, has_seen_tutorial)
  WHERE user_id = p_user_id;

  -- 返回更新后的状态
  CALL get_user_state(p_user_id);
END //
DELIMITER ;
```

#### 2.2 用户收藏逻辑
**当前实现位置**：`backend/routes/user.js` 第175-296行
**可优化内容**：
- 将获取收藏、收藏漂流瓶和取消收藏的逻辑移入存储过程
- 在存储过程中处理数据查询和更新

**建议存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS get_user_saved_bottles(
  IN p_user_id INT
)
BEGIN
  -- 获取用户收藏的漂流瓶
  SELECT
    b.id,
    b.message,
    COALESCE(b.author_name, u.username) AS author,
    DATE(b.created_at) AS date,
    b.views,
    DATE(s.saved_at) AS savedDate,
    s.annotation,
    COALESCE(like_stats.like_count, 0) AS likes,
    COALESCE(dislike_stats.dislike_count, 0) AS dislikes
  FROM user_bottle_saves s
  JOIN bottles b ON s.bottle_id = b.id
  JOIN users u ON b.user_id = u.id
  LEFT JOIN (
    SELECT bottle_id, COUNT(*) AS like_count
    FROM user_bottle_reactions
    WHERE reaction_type = 'like'
    GROUP BY bottle_id
  ) like_stats ON b.id = like_stats.bottle_id
  LEFT JOIN (
    SELECT bottle_id, COUNT(*) AS dislike_count
    FROM user_bottle_reactions
    WHERE reaction_type = 'dislike'
    GROUP BY bottle_id
  ) dislike_stats ON b.id = dislike_stats.bottle_id
  WHERE s.user_id = p_user_id AND b.is_active = TRUE
  ORDER BY s.saved_at DESC;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE IF NOT EXISTS save_bottle(
  IN p_user_id INT,
  IN p_bottle_id INT,
  IN p_annotation VARCHAR(10)
)
BEGIN
  DECLARE v_bottle_exists INT;
  DECLARE v_save_exists INT;

  -- 检查漂流瓶是否存在
  SELECT COUNT(*) INTO v_bottle_exists
  FROM bottles
  WHERE id = p_bottle_id AND is_active = TRUE;

  IF v_bottle_exists = 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '漂流瓶不存在';
  END IF;

  -- 检查是否已经收藏过
  SELECT COUNT(*) INTO v_save_exists
  FROM user_bottle_saves
  WHERE user_id = p_user_id AND bottle_id = p_bottle_id;

  IF v_save_exists > 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '已经收藏过这个漂流瓶';
  END IF;

  -- 收藏漂流瓶
  INSERT INTO user_bottle_saves (user_id, bottle_id, annotation)
  VALUES (p_user_id, p_bottle_id, p_annotation);

  SELECT '收藏成功' AS message;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE IF NOT EXISTS unsave_bottle(
  IN p_user_id INT,
  IN p_bottle_id INT
)
BEGIN
  DECLARE v_affected_rows INT;

  -- 取消收藏
  DELETE FROM user_bottle_saves
  WHERE user_id = p_user_id AND bottle_id = p_bottle_id;

  SET v_affected_rows = ROW_COUNT();

  IF v_affected_rows = 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '未找到收藏记录';
  END IF;

  SELECT '取消收藏成功' AS message;
END //
DELIMITER ;
```

### 3. 用户认证相关逻辑

#### 3.1 用户注册逻辑
**当前实现位置**：`backend/routes/auth.js` 第10-85行
**可优化内容**：
- 将用户注册逻辑移入存储过程
- 在存储过程中处理用户创建和状态初始化

**建议存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS register_user(
  IN p_username VARCHAR(50),
  IN p_email VARCHAR(100),
  IN p_password_hash VARCHAR(255),
  OUT p_user_id INT,
  OUT p_message VARCHAR(255)
)
BEGIN
  DECLARE v_username_exists INT;
  DECLARE v_email_exists INT;

  -- 检查用户名是否已存在
  SELECT COUNT(*) INTO v_username_exists
  FROM users
  WHERE username = p_username;

  IF v_username_exists > 0 THEN
    SET p_message = '用户名已存在';
  ELSE
    -- 检查邮箱是否已存在（如果提供了邮箱）
    IF p_email IS NOT NULL AND p_email != '' THEN
      SELECT COUNT(*) INTO v_email_exists
      FROM users
      WHERE email = p_email;

      IF v_email_exists > 0 THEN
        SET p_message = '邮箱已被注册';
      END IF;
    END IF;

    -- 如果没有错误，创建用户
    IF p_message IS NULL THEN
      INSERT INTO users (username, email, password_hash)
      VALUES (p_username, p_email, p_password_hash);

      SET p_user_id = LAST_INSERT_ID();

      -- 创建用户状态记录
      INSERT INTO user_states (user_id) VALUES (p_user_id);

      SET p_message = '注册成功';
    END IF;
  END IF;
END //
DELIMITER ;
```

#### 3.2 用户登录逻辑
**当前实现位置**：`backend/routes/auth.js` 第88-142行
**可优化内容**：
- 将用户登录逻辑移入存储过程
- 在存储过程中处理密码验证和登录时间更新

**建议存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS login_user(
  IN p_username VARCHAR(50),
  IN p_password_hash VARCHAR(255),
  OUT p_user_id INT,
  OUT p_username_out VARCHAR(50),
  OUT p_email VARCHAR(100),
  OUT p_message VARCHAR(255)
)
BEGIN
  DECLARE v_password_hash VARCHAR(255);
  DECLARE v_is_active BOOLEAN;

  -- 查找用户
  SELECT 
    id, 
    password_hash, 
    username, 
    email, 
    is_active 
  INTO 
    p_user_id, 
    v_password_hash, 
    p_username_out, 
    p_email, 
    v_is_active
  FROM users
  WHERE username = p_username;

  -- 检查用户是否存在
  IF p_user_id IS NULL THEN
    SET p_message = '用户名或密码错误';
  -- 检查用户是否激活
  ELSEIF v_is_active = FALSE THEN
    SET p_message = '账户已被禁用';
  -- 验证密码（注意：实际密码验证应在应用层进行，此处仅为示例）
  ELSEIF v_password_hash != p_password_hash THEN
    SET p_message = '用户名或密码错误';
  ELSE
    -- 更新最后登录时间
    UPDATE users 
    SET last_login = NOW() 
    WHERE id = p_user_id;

    SET p_message = '登录成功';
  END IF;
END //
DELIMITER ;
```

## 实施建议

1. **分阶段实施**：
   - 首先实施漂流瓶相关存储过程
   - 然后实施用户状态管理存储过程
   - 最后实施用户认证相关存储过程

2. **保持向后兼容**：
   - 保留现有API接口，内部调用存储过程
   - 逐步迁移前端代码以使用新的API

3. **测试策略**：
   - 为每个存储过程编写单元测试
   - 进行集成测试确保API行为一致
   - 进行性能测试确保优化效果

4. **文档更新**：
   - 更新API文档
   - 更新数据库设计文档
   - 创建存储过程使用指南

## 总结

通过将业务逻辑移入数据库存储过程，可以实现以下优势：

1. **提高性能**：减少网络往返次数，利用数据库优化
2. **增强安全性**：逻辑集中在数据库，减少攻击面
3. **简化维护**：业务逻辑集中管理，易于更新和维护
4. **提升一致性**：确保所有应用使用相同的业务逻辑

前端可以专注于UI展示和用户交互，后端主要负责API路由和认证，而复杂的业务逻辑则由数据库存储过程处理，实现更清晰的职责分离。
